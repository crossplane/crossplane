// Code generated by github.com/jmattheis/goverter, DO NOT EDIT.
//go:build !goverter

package v1

import (
	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

type GeneratedRevisionSpecConverter struct{}

func (c *GeneratedRevisionSpecConverter) FromRevisionSpec(source CompositionRevisionSpec) CompositionSpec {
	var v1CompositionSpec CompositionSpec
	v1CompositionSpec.CompositeTypeRef = c.v1TypeReferenceToV1TypeReference(source.CompositeTypeRef)
	v1CompositionSpec.Mode = c.v1CompositionModeToV1CompositionMode(source.Mode)
	if source.Pipeline != nil {
		v1CompositionSpec.Pipeline = make([]PipelineStep, len(source.Pipeline))
		for i := 0; i < len(source.Pipeline); i++ {
			v1CompositionSpec.Pipeline[i] = c.v1PipelineStepToV1PipelineStep(source.Pipeline[i])
		}
	}
	if source.WriteConnectionSecretsToNamespace != nil {
		xstring := *source.WriteConnectionSecretsToNamespace
		v1CompositionSpec.WriteConnectionSecretsToNamespace = &xstring
	}
	return v1CompositionSpec
}
func (c *GeneratedRevisionSpecConverter) ToRevisionSpec(source CompositionSpec) CompositionRevisionSpec {
	var v1CompositionRevisionSpec CompositionRevisionSpec
	v1CompositionRevisionSpec.CompositeTypeRef = c.v1TypeReferenceToV1TypeReference(source.CompositeTypeRef)
	v1CompositionRevisionSpec.Mode = c.v1CompositionModeToV1CompositionMode(source.Mode)
	if source.Pipeline != nil {
		v1CompositionRevisionSpec.Pipeline = make([]PipelineStep, len(source.Pipeline))
		for i := 0; i < len(source.Pipeline); i++ {
			v1CompositionRevisionSpec.Pipeline[i] = c.v1PipelineStepToV1PipelineStep(source.Pipeline[i])
		}
	}
	if source.WriteConnectionSecretsToNamespace != nil {
		xstring := *source.WriteConnectionSecretsToNamespace
		v1CompositionRevisionSpec.WriteConnectionSecretsToNamespace = &xstring
	}
	return v1CompositionRevisionSpec
}
func (c *GeneratedRevisionSpecConverter) pRuntimeRawExtensionToPRuntimeRawExtension(source *runtime.RawExtension) *runtime.RawExtension {
	var pRuntimeRawExtension *runtime.RawExtension
	if source != nil {
		runtimeRawExtension := ConvertRawExtension((*source))
		pRuntimeRawExtension = &runtimeRawExtension
	}
	return pRuntimeRawExtension
}
func (c *GeneratedRevisionSpecConverter) pV1SecretReferenceToPV1SecretReference(source *v1.SecretReference) *v1.SecretReference {
	var pV1SecretReference *v1.SecretReference
	if source != nil {
		var v1SecretReference v1.SecretReference
		v1SecretReference.Name = (*source).Name
		v1SecretReference.Namespace = (*source).Namespace
		pV1SecretReference = &v1SecretReference
	}
	return pV1SecretReference
}
func (c *GeneratedRevisionSpecConverter) v1CompositionModeToV1CompositionMode(source CompositionMode) CompositionMode {
	var v1CompositionMode CompositionMode
	switch source {
	case CompositionModePipeline:
		v1CompositionMode = CompositionModePipeline
	default: // ignored
	}
	return v1CompositionMode
}
func (c *GeneratedRevisionSpecConverter) v1FunctionCredentialsSourceToV1FunctionCredentialsSource(source FunctionCredentialsSource) FunctionCredentialsSource {
	var v1FunctionCredentialsSource FunctionCredentialsSource
	switch source {
	case FunctionCredentialsSourceNone:
		v1FunctionCredentialsSource = FunctionCredentialsSourceNone
	case FunctionCredentialsSourceSecret:
		v1FunctionCredentialsSource = FunctionCredentialsSourceSecret
	default: // ignored
	}
	return v1FunctionCredentialsSource
}
func (c *GeneratedRevisionSpecConverter) v1FunctionCredentialsToV1FunctionCredentials(source FunctionCredentials) FunctionCredentials {
	var v1FunctionCredentials FunctionCredentials
	v1FunctionCredentials.Name = source.Name
	v1FunctionCredentials.Source = c.v1FunctionCredentialsSourceToV1FunctionCredentialsSource(source.Source)
	v1FunctionCredentials.SecretRef = c.pV1SecretReferenceToPV1SecretReference(source.SecretRef)
	return v1FunctionCredentials
}
func (c *GeneratedRevisionSpecConverter) v1FunctionReferenceToV1FunctionReference(source FunctionReference) FunctionReference {
	var v1FunctionReference FunctionReference
	v1FunctionReference.Name = source.Name
	return v1FunctionReference
}
func (c *GeneratedRevisionSpecConverter) v1PipelineStepToV1PipelineStep(source PipelineStep) PipelineStep {
	var v1PipelineStep PipelineStep
	v1PipelineStep.Step = source.Step
	v1PipelineStep.FunctionRef = c.v1FunctionReferenceToV1FunctionReference(source.FunctionRef)
	v1PipelineStep.Input = c.pRuntimeRawExtensionToPRuntimeRawExtension(source.Input)
	if source.Credentials != nil {
		v1PipelineStep.Credentials = make([]FunctionCredentials, len(source.Credentials))
		for i := 0; i < len(source.Credentials); i++ {
			v1PipelineStep.Credentials[i] = c.v1FunctionCredentialsToV1FunctionCredentials(source.Credentials[i])
		}
	}
	return v1PipelineStep
}
func (c *GeneratedRevisionSpecConverter) v1TypeReferenceToV1TypeReference(source TypeReference) TypeReference {
	var v1TypeReference TypeReference
	v1TypeReference.APIVersion = source.APIVersion
	v1TypeReference.Kind = source.Kind
	return v1TypeReference
}
