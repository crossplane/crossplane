# Webhooks in Crossplane

* Owner: Muvaffak Onuş (@muvaf)
* Reviewers: Crossplane Maintainers
* Status: Draft

## Background

In Kubernetes, resource operations go through several steps of processes when
they are sent to `etcd` by the user. These steps include various compiled-in
admission controllers.

> An admission controller is a piece of code that intercepts requests to the
> Kubernetes API server prior to persistence of the object, but after the
> request is authenticated and authorized.

Additional to the ones that are compiled-in, Kubernetes allows users to register
their own webhook servers and API Server makes requests to those webhook servers
as needed. There are three main types of webhooks:
* Mutation: Accepts a resource, makes changes and returns it to API Server.
* Admission: Accepts a resource and returns back a decision whether the
  operation on that resource should be allowed.
* Conversion: Accepts a resource and a version string as destination version,
  then it creates the resource in the schema of that given version and returns
  it  back to API Server.

The main difference between usual Kubernetes controllers is that admission
controllers work before the resource makes it to persistent storage. This allows
immediate rejection of the action performed by the users and various operations
that you want to do before persisting it and making it available for controllers
to reconcile.

In Crossplane, we frequently need webhooks for various use cases at different
levels.

## Use Cases

Let's list all the known issues that can be solved by using webhooks and with
which operation type.

* Conversion webhooks for version changes in CRDs [#1584](https://github.com/crossplane/crossplane/issues/1584)
  * Conversion operation for **all kinds**
* Validate composition base templates [#1476](https://github.com/crossplane/crossplane/issues/1476)
  * Validation in `CREATE` operation of `Composition`
* Validate schemas in XRD [#1752](https://github.com/crossplane/crossplane/issues/1752)
  * Validation in `CREATE` operation of `CompositeResourceDefinition`
* Immutable resource fields [#727](https://github.com/crossplane/crossplane/issues/727)
  * Validation in `UPDATE` operation of **every managed resource**
  * The semantics in the KEP covering this is `can-be-set-only-in-creation`
    while what we want `cannot-be-changed-once-set`. So we can't really use
    upstream impl. when it's implemented.
* Composition scheduling [#967](https://github.com/crossplane/crossplane/issues/967)
  * Mutation in `CREATE` operation of `Composition`
* Support `oneOf` semantics validation for discriminator fields [#950](https://github.com/crossplane/crossplane/issues/950)
  * Implemented in Kubernetes, coming to controller-runtime.

## Implementation Requirements

As we can see, there are multiple use cases each requiring different levels of
customizations. While we want to streamline webhook implementation by providing
abstractions, we need to allow granular customizations to cover these cases. The
following list is roughly what we can start with as configurable:

* Mutation/Validation/Conversion webhook types.
* `CREATE` and `UPDATE` operation types.
* Static kind specification.
  * Dynamic kind specification would be useful for XRD-defined kinds, though
    it's a nice-to-have rather than a goal for now.

For the use cases that work with statically defined types like `Composition`, we
can use lower level abstractions if necessary since they are implemented only
once. So, we want to optimize our abstraction for the ones that require per-kind
implementaton: immutable fields, conversion webhooks.

### Immutable Fields

This problem can be solved by a generic implementation that takes a list of
field paths per kind, which can either be specified manually or generated by a
tool scanning for a specific marker in API type file. I believe our existing
`fieldpath` package in `crossplane-runtime` would be very handy here. So, we
will have a separate Go implementation for this use case that may or may not use
the abstraction we define.

### Conversion Webhooks

The main essence of conversion webhook problem is essentially field matching and
doing transforms in-between. These operations are not very complex but they are
also hard to generalize for every kind of CRDs we have. Specifically, when a new
version of provider API that has breaking changes is released, we can't really
guess how complex the conversion process will be. That's why we want to give
code-level flexibility to owners of the CRDs while keeping the webhook mechanics
that are generic be handled automatically by our abstraction layer.

## Upstream Tools

There are two main mechanisms that upstream provides:
* Kubebuilder automatically generates webhook registration YAMLs for the marked
  structs.
  * Useful for only mutation and admission; conversion needs a patch on the CRD.
* `controller-runtime` provides two abstraction layers.
  * Low level `mgr.GetWebhookServer().Register(path string, hook http.Handler)`.
  * High level interfaces.
    * `Defaulter()` for mutation.
    * `Validate{Create,Update,Delete}() error` for admission.
    * `Convert{To,From}(obj)` for conversion.

Kubebuilder generating YAMLs would work for us; it's designed similar to CRD
generation and fairly simple. No additional YAML is needed for conversion but
CRD needs to point to the `Service` of webhook, though it's no-op if the CRD has
only one version.

For abstractions, we need to look at a little deeper.

[Mutation](https://github.com/kubernetes-sigs/controller-runtime/blob/0208f43/pkg/webhook/admission/defaulter.go#L28)
webhook:
```golang
// Defaulter defines functions for setting defaults on resources
type Defaulter interface {
  runtime.Object
  Default()
}
```

[Validation](https://github.com/kubernetes-sigs/controller-runtime/blob/8161d1c/pkg/webhook/admission/validator.go#L30)
webhook:
```golang
// Validator defines functions for validating an operation
type Validator interface {
  runtime.Object
  ValidateCreate() error
  ValidateUpdate(old runtime.Object) error
  ValidateDelete() error
}
```

[Conversion](https://github.com/kubernetes-sigs/controller-runtime/blob/836b363d731dbbea5591db3c7ca2a36c2dd6c151/pkg/conversion/conversion.go#L22)
webhook:
```golang
// Convertible defines capability of a type to convertible i.e. it can be converted to/from a hub type.
type Convertible interface {
  runtime.Object
  ConvertTo(dst Hub) error
  ConvertFrom(src Hub) error
}

// Hub marks that a given type is the hub type for conversion. This means that
// all conversions will first convert to the hub type, then convert from the hub
// type to the destination type. All types besides the hub type should implement
// Convertible.
type Hub interface {
  runtime.Object
  Hub()
}
```

We see that the interfaces include `runtime.Object`, which means the functions
need to be members of the kinds, i.e. `RDSInstance` struct needs to implements
these functions. The abstraction layer that accepts `Defaulter` and `Validator`
look pretty similar so I'll copy only the [mutation
one](https://github.com/kubernetes-sigs/controller-runtime/blob/0208f43/pkg/webhook/admission/defaulter.go#L54):

```golang
// Handle handles admission requests.
func (h *mutatingHandler) Handle(ctx context.Context, req Request) Response {
  if h.defaulter == nil {
    panic("defaulter should never be nil")
  }

  // Get the object in the request
  obj := h.defaulter.DeepCopyObject().(Defaulter)
  err := h.decoder.Decode(req, obj)
  if err != nil {
    return Errored(http.StatusBadRequest, err)
  }

  // Default the object
  obj.Default()
  marshalled, err := json.Marshal(obj)
  if err != nil {
    return Errored(http.StatusInternalServerError, err)
  }

  // Create the patch
  return PatchResponseFromRaw(req.Object.Raw, marshalled)
}
```

The conversion webhook implementation is a bit [more
complex](https://github.com/kubernetes-sigs/controller-runtime/blob/master/pkg/webhook/conversion/conversion.go#L22)
due to the marshalling and version checks that need to happen. However, it seems
that some of the cases it needs to handle [are not
necessary](https://github.com/kubernetes-sigs/controller-runtime/issues/1388) in
v1 CRD mechanics.

These high level abstractions are fairly simple and they have a few drawbacks:
* They require implementation in API type packages and we want to keep API type
  packages as lean as possible so that external users of those Go packages do
  not have to depend on things that are irrelevant to them. However, there are
  some cases that might require including cloud provider SDK and/or `client`
  package from controller-runtime:
  * Let's say GCP decides to add a new field in the new version of SDK and we
    want to include it in the new `apiVersion`. However, in order to make
    queries the value of that field needs to be known, hence we need to make a
    `GET` call to the provider API, which means we'd have to import GCP Go SDK.
    We update SDKs very infrequently so we have not encountered this but it's
    possible.
  * If we decide to expand abilities of webhooks, we might need other libraries.
    For example, if admission webhook has a functionality checking the
    `ServiceAccount` of the action taker, then we probably need to call
    api-server to get its RBAC details, which would require importing `client`
    package and some cumbersome logic to make it available in the CRD struct.
* `Default` is not a well-suited name for our mutation operations we expect to
  do since we'll use the kubebuilder [`default`
  marker](https://book.kubebuilder.io/reference/markers/crd-validation.html) for
  this functionality.

On the other hand, while we could work with the low level one, we never really
need to customize encoder/decoders and deal with `http.Handler` interface. We'd
need to build a layer similar to the one we described here as high level
abstraction but in `crossplane-runtime`.

## Proposal

There are four main pieces of a webhook:
* Actual Go implementation of the logic.
* Exposing an HTTP server accepting requests from Kubernetes API Server and
  responding properly.
* Handing off certificates to both API Server and the webhook server since TLS
  is required.
* Making sure the server is registered to Kubernetes API Server.

For the first two items, we will use controller-runtime high level abstraction
layer directly from where it's needed without a shim in crossplane-runtime. The
drawbacks mentioned do not bite us for the current use cases and switching to
another implementation is a non-breaking backend change, hence we can do it when
we actually need it. But in order the expose the HTTP server in the cluster, we
need additional functionality in package manager.

### Exposing Webhook Server

When a controller-runtime manager starts, the webhook server is also started
automatically. So, as long as necessary implementations are there and hooked up
with the main manager object, we have the server up and running. But in order to
expose it to cluster, we need to create a `Service` resource similar to
`Deployment` of the controller.

The package manager will create an opinionated `Service` resource for the
providers it installs and this will require Crossplane to have necessary RBAC
for managing `Service` objects, too. Though it could be limited to which
namespace it's installed, again similar to `Deployment` RBAC.

### Certificate Distribution

Kubernetes API server enforces use of TLS for the communication between the API
server and the webhook server. The webhook server needs to have the TLS Key &
Certificate and the API server needs to have a certificate bundle that is signed
by that key. Normally, the controllers in the wild have to include a mechanism
to generate the certificate to use in their webhook servers and that usually
renders a bad UX for the admins since it either requires manual creation of the
certificates or having `cert-manager` installed.

We will utilize the fact that we are orchestrating the installation of provider
controllers by our package manager. When Crossplane is first installed, it will
check if a TLS `Secret` is given and it exists, if not, it will generate a new
one. Then in every provider installation, it will mount this `Secret` to the
provider container to use as the certificate & key. Since it also installs the
necessary YAMLs that register the webhooks to API Server, it will inject the CA
Bundle before the creation of those resources, which are
`MutatingWebhookConfiguration`, `ValidatingWebhookConfiguration` and the
`spec.webhook` part of `CustomResourceDefinition`s.

While the provider installations will be handled this way, Crossplane doesn't
orchestrate the installation of itself. But we will again utilize the fact that
we have package manager, hence necessary RBAC to create the registration YAMLs.
So, what we will do is that Crossplane will register its own webhook
configurations right after it makes sure the TLS secret is there during the
initialization phase of the process.

Overall, we will have an option in Helm chart to allow admins to provide their
own TLS secrets but default mode will be that Crossplane will generate the
`Secret` if it doesn't exist and use its CA Bundle in all webhook
configurations, including its own.

### Mutating/Validating Webhook Registration

The following excerpt includes examples of YAMLs necessary for mutation and
admission:
```yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: mutation-config
webhooks:
  - admissionReviewVersions:
    - v1beta1
    name: mapplication.kb.io
    clientConfig:
      caBundle: ${CA_BUNDLE}
      service:
        name: webhook-service
        namespace: default
        path: /mutate
    rules:
      - apiGroups:
          - apps
      - apiVersions:
          - v1
        resources:
          - deployments
    sideEffects: None
---
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: "pod-policy.example.com"
webhooks:
- name: "pod-policy.example.com"
  rules:
  - apiGroups:   [""]
    apiVersions: ["v1"]
    operations:  ["CREATE"]
    resources:   ["pods"]
    scope:       "Namespaced"
  clientConfig:
    service:
      namespace: "example-namespace"
      name: "example-service"
    caBundle: ${CA_BUNDLE}
  admissionReviewVersions: ["v1", "v1beta1"]
  sideEffects: None
  timeoutSeconds: 5
```

The generation of these YAMLs can be handled using `kubebuilder`. The following
is an example marker we'd need to add to CRD struct:
```
// +kubebuilder:webhook:path=/mutate-batch-tutorial-kubebuilder-io-v1-cronjob,mutating=true,failurePolicy=fail,groups=batch.tutorial.kubebuilder.io,resources=cronjobs,verbs=create;update,versions=v1,name=mcronjob.kb.io
```

We will use this marker to generate these YAMLs similar to CRD YAMLs. Similarly,
they need to be included in the package artifact so a `webhooks` folder will be
added to the existing `package` folder which will look like the following:
```
.
├── crds
├── webhooks
└── crossplane.yaml
```

For core Crossplane webhook configurations; we will create them in Go code
during the initialization phase, inject CA Bundle and create as mentioned in the
earlier section.

### Conversion Webhook Registration

This case is different than other webhook registrations as it's not a separate
resource on its own but a field in the `CustomResourceDefinition`. Upstream
controller-runtime webhook server exposes only one path `/convert` for all
conversion operations. After the request comes in, it does a type check to
decide which conversion functions to run. The patching of
`CustomResourceDefinition` is left to client side tooling, i.e. no kubebuilder
markers available.

For provider CRDs, the package manager will inject the conversion webhook
configuration to every `CustomResourceDefinition` it installs because it's safe
to have it there even if there is only one `apiVersion` defined.

The Crossplane CRDs will be patched by Crossplane itself during the
initialization phase after ensuring TLS `Secret` is there. Since Crossplane
manages the lifecycle of its own CRDs using the init container, this should be
fine for both installation and upgrade scenarios because init container will be
done before the controller comes up and asks for the new version.

### Immutable Field Webhook

Currently, we mark the fields of CRDs as `// +immutable` but it doesn't have any
implication in practice. It'd be very useful to reject changes to immutable
fields especially because the controller cannot detect whether the field has
always been there or changed. In most cases, the fields that cannot be updated
are not included in `Update` requests, hence go unnoticed even when you change
them with no error.

We will implement a generic webhook server in `crossplane-runtime` that will
take a list of field paths in a YAML that looks like the following:
```yaml
crds:
- vpcs.ec2.aws.crossplane.io/v1beta1:
  immutableFieldPaths:
  - spec.forProvider.region
- rdsinstances.database.aws.crossplane.io/v1beta1:
  immutableFieldPaths:
  - spec.forProvider.vpcId
...
```

We will start with this manually written list initially. The next step would be
to have a tool in `crossplane-tools` to scan API types, extract the field paths
of the immutable fields of the CRDs and write it to a file in this format.
